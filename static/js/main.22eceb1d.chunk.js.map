{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["handNameList","last","time","Date","x","y","z","App","props","state","isStarted","isGranted","handName","threshold","shaked","deviceMotionHandler","bind","requestDeviceMotionPermission","setShuffleHand","event","current","accelerationIncludingGravity","this","deltaX","Math","abs","deltaY","deltaZ","getTime","floor","random","setState","setTimeout","DeviceMotionEvent","requestPermission","then","permissionState","window","addEventListener","catch","error","alert","DeviceOrientationEvent","className","onClick","src","class","React","Component","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.22eceb1d.chunk.js","sourcesContent":["import React from 'react'\n\nconst handNameList = [\"guu\", \"choki\", \"paa\"]\nconst last = {\n  time: new Date(),\n  x: null,\n  y: null,\n  z: null,\n}\n\nclass App extends React.Component {\n\n  state = {\n    isStarted: false,\n    isGranted: false,\n    handName: null,\n    threshold: 4,\n    shaked: false,\n  }\n\n  constructor(props) {\n    super(props)\n    this.deviceMotionHandler = this.deviceMotionHandler.bind(this)\n    this.requestDeviceMotionPermission = this.requestDeviceMotionPermission.bind(this)\n    this.setShuffleHand = this.setShuffleHand.bind(this)\n  }\n\n  deviceMotionHandler(event) {\n    const current = event.accelerationIncludingGravity\n    const { threshold } = this.state\n\n    if ((last.x === null) && (last.y === null) && (last.z === null)) {\n      last.x = current.x\n      last.y = current.y\n      last.z = current.z\n      return\n    }\n\n    const deltaX = Math.abs(last.x - current.x)\n    const deltaY = Math.abs(last.y - current.y)\n    const deltaZ = Math.abs(last.z - current.z)\n\n    // shake判定\n    if (deltaX > threshold || deltaY > threshold || deltaZ > threshold) {\n      this.setShuffleHand()\n    }\n\n    last.x = current.x\n    last.y = current.y\n    last.z = current.z\n  }\n\n  setShuffleHand() {\n    // 前回から 300ms 時間が経ったか\n    if ((new Date()).getTime() - last.time.getTime() > 300) {\n      const handName = handNameList[Math.floor(Math.random() * 3)]\n      this.setState({\n        handName,\n        shaked: true\n      })\n\n      setTimeout(() => {\n        this.setState({ shaked: false })\n      }, 100);\n\n      last.time = new Date()\n    }\n  }\n\n  requestDeviceMotionPermission() {\n    if (\n      DeviceMotionEvent &&\n      typeof DeviceMotionEvent.requestPermission === 'function'\n    ) {\n      // iOS 13+ の Safari\n      // 許可を取得\n      DeviceMotionEvent.requestPermission()\n      .then(permissionState => {\n        if (permissionState === 'granted') {\n          // 許可を得られた場合、devicemotionをイベントリスナーに追加\n          window.addEventListener('devicemotion', this.deviceMotionHandler, false)\n          this.setState({\n            isStarted: true,\n            isGranted: true,\n          })\n        } else {\n          // 許可を得られなかった場合の処理\n          this.setState({\n            isStarted: true,\n            isGranted: false,\n          })\n        }\n      })\n      .catch(error => {\n        // https通信でない場合などで許可を取得できなかった場合\n        alert(error)\n      })\n    } else if (DeviceOrientationEvent) {\n      // 上記以外のブラウザ\n      window.addEventListener('devicemotion', this.deviceMotionHandler, false)\n      this.setState({\n        isStarted: true,\n        isGranted: true,\n      })\n    } else {\n      // このブラウザではご利用になれません。\n    }\n  }\n\n  render() {\n    const {\n      isStarted,\n      isGranted,\n      handName,\n      threshold,\n      shaked,\n    } = this.state\n\n    if (!isStarted) {\n      return (\n        <div className=\"app\">\n          <div className=\"title-container\">\n            <h1 className=\"title\">〜 振ってジャンケン 〜</h1>\n            <div className=\"help\">スマホやタブレットでみてね</div>\n          </div>\n          <div className=\"hands-container\">\n            <ul className=\"start-hands\">\n              <li><img src={`images/guu.png`}  /></li>\n              <li><img src={`images/choki.png`} /></li>\n              <li><img src={`images/paa.png`} /></li>\n            </ul>\n          </div>\n          <div class=\"button-container\">\n            <a\n              className=\"button\"\n              onClick={() => this.requestDeviceMotionPermission()}\n            >\n              スタート！\n            </a>\n          </div>\n        </div>\n      )\n    } else if (!isGranted) {\n      return (\n        <div className=\"app\">\n          許可を取得できませんでした・・・😢\n        </div>\n      )\n    } else if (handName === null) {\n      return (\n        <div className=\"app started\" onClick={this.setShuffleHand}>\n          <div className=\"title-container\">\n            <div className=\"title\">振ると変わるよ！</div>\n            <div className=\"help\">タッチでもOK!</div>\n          </div>\n          <div className=\"hand-image-container\">\n            <div className=\"hand-image-wrapper\">\n              <div className=\"hand-image\">\n                <img src={`images/guu.png`} />\n              </div>\n            </div>\n          </div>\n        </div>\n      )\n    } else {\n      return (\n        <div className={`app started ${shaked ? 'shaked' : ''}`} onClick={this.setShuffleHand}>\n          <div className=\"hand-image-container\">\n            <div className=\"hand-image-wrapper\">\n              <div className=\"hand-image\">\n                <img src={`images/${handName}.png`} />\n              </div>\n            </div>\n          </div>\n        </div>\n      )\n    }\n  }\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.sass';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}